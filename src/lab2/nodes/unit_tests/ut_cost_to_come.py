import numpy as np

def cost_to_come(trajectory_o, rot_cost_coefficient=0):
        #The cost to get to a node from lavalle 
        # print("TO DO: Implement a cost to come metric")
        # assume trajectory_o is 3xn numpy array generated by 'connect_node_to_point()'
        # [x, y, theta]
        # From now, the cost is calculated the Euclidean distance between points, ignoring rotation(i.e rot_cost_coefficient=0). 
        # Potentially we can tune the cost function for better performance
        
        points = np.transpose(trajectory_o)  # changing 3xn to nx3
        total_cost = 0
        for i in range(len(points) - 1):
            point1 = points[i, 0 : 2]
            point2 = points[i + 1, 0 : 2]
            angle_difference = points[i, 3] - points[i + 1, 3]
            # print(point1,point2)
            total_cost += np.linalg.norm(point1 - point2) + rot_cost_coefficient * angle_difference
        return total_cost


def main():
    
    # test 1
    trajectory_o_1 = np.array([[1,2,3,4,5], [2,3,4,5,6],[0, np.pi, np.pi/2, np.pi/6, 0]])  # should output
    cost_1 = cost_to_come(trajectory_o_1, rot_cost_coefficient=0)
    assert cost_1 == 4*np.sqrt(2)
    print("passed all tests")
    return 

if __name__ == '__main__':
    main()
